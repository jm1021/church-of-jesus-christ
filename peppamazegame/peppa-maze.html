---
layout: opencs
title: "Peppa Pig Maze"
description: "Guide Peppa Pig through a maze to learn CS fun facts"
permalink: /peppa-maze/
---

<style>
  body {
    margin: 0;
    font-family: Arial, sans-serif;
    text-align: center;
    background: url("{{ site.baseurl }}/peppamazegame/peppapigducks.jpg") no-repeat center center fixed;
    background-size: cover;
  }

  canvas {
    border: 2px solid black;
    display: block;
    margin: 20px auto;
    background: rgba(240, 240, 240, 0.95);
  }

  #questionBox {
    margin: 10px auto;
    padding: 20px;
    width: 80%;
    max-width: 600px;
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
    text-align: left;
    display: none;
  }

  #questionBox * {
    color: black !important;
  }


  #questionText {
    color: black;
    /* Main question text color - dark blue */
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 15px;
  }

  .answer-btn {
    display: block;
    width: 100%;
    padding: 12px;
    margin: 8px 0;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s;
  }

  .answer-btn:hover {
    background: #45a049;
  }

  #feedback {
    margin-top: 15px;
    padding: 15px;
    border-radius: 6px;
    display: none;
  }

  .correct {
    background: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
  }

  .incorrect {
    background: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
  }

  #diceControls {
    margin: 20px auto;
    display: flex;
    justify-content: center;
    gap: 40px;
    flex-wrap: wrap;
  }

  .playerDice {
    background: rgba(255, 255, 255, 0.9);
    padding: 15px;
    border-radius: 12px;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
  }

  .diceButton {
    background: linear-gradient(145deg, #ff69b4, #ff1493);
    color: white;
    border: none;
    padding: 15px 30px;
    font-size: 18px;
    border-radius: 8px;
    cursor: pointer;
    margin: 10px;
    transition: transform 0.2s;
  }

  .diceButton:hover:not(:disabled) {
    transform: scale(1.05);
  }

  .diceButton:disabled {
    background: #ccc;
    cursor: not-allowed;
  }

  .diceDisplay {
    font-size: 48px;
    margin: 10px 0;
  }

  .movesLeft {
    font-size: 18px;
    color: #2a5d9f;
    font-weight: bold;
  }

  .playerLabel {
    font-size: 20px;
    font-weight: bold;
    margin-bottom: 10px;
  }

  .player1Label {
    color: #ff69b4;
  }

  .player2Label {
    color: #4169e1;
  }

  .current-turn {
    border: 3px solid #ffd700;
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
  }

  #turnIndicator {
    margin: 15px auto;
    padding: 10px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    font-size: 20px;
    font-weight: bold;
    max-width: 300px;
  }

  #modeSelection {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  #modeSelection.hidden {
    display: none;
  }

  .mode-container {
    background: white;
    padding: 40px;
    border-radius: 20px;
    text-align: center;
  }

  .mode-container h2 {
    color: #2a5d9f;
    margin-bottom: 30px;
  }

  .mode-btn {
    background: linear-gradient(145deg, #ff69b4, #ff1493);
    color: white;
    border: none;
    padding: 20px 40px;
    font-size: 20px;
    border-radius: 12px;
    cursor: pointer;
    margin: 10px;
    transition: transform 0.2s;
  }

  .mode-btn:hover {
    transform: scale(1.05);
  }

  select {
    padding: 12px 20px;
    font-size: 16px;
    margin-bottom: 20px;
    border-radius: 8px;
    border: 2px solid #ccc;
    background: white;
    color: #333;
    cursor: pointer;
    min-width: 250px;
  }

  select:focus {
    outline: none;
    border-color: #ff69b4;
  }

  label {
    display: block;
    font-size: 18px;
    margin-bottom: 10px;
    color: #2a5d9f;
    font-weight: bold;
  }
</style>
</head>

<body>

  <div id="modeSelection">
    <div class="mode-container">
      <h2>üê∑ Choose Game Mode üêñ</h2>
      <label for="lessonSelect">Select Lesson Topic:</label>
      <select id="lessonSelect">
        <option value="variables">Variables & Assignments</option>
        <option value="algorithms">Developing Algorithms</option>
        <option value="algorithmic efficiency">Algorithmic Efficiency</option>
      </select><br>
      <button class="mode-btn" onclick="startGame(1)">Single Player</button>
      <button class="mode-btn" onclick="startGame(2)">Two Players</button>
    </div>
  </div>

  <div id="turnIndicator">Peppa's Turn!</div>
  <div id="questionProgress" style="margin:10px auto; max-width:300px;">Questions used: 0 / 0 <button id="resetProgress" style="margin-left:10px;">Reset</button></div>

  <div id="gameContainer"></div>

  <div id="diceControls">
    <div class="playerDice" id="player1Dice">
      <div class="playerLabel player1Label">üê∑ Peppa (WASD)</div>
      <button id="rollDice1" class="diceButton">Roll Dice</button>
      <div id="dice1" class="diceDisplay">üé≤</div>
      <div id="moves1" class="movesLeft">Moves left: 0</div>
    </div>
    <div class="playerDice" id="player2Dice">
      <div class="playerLabel player2Label">üêñ George (Arrow Keys)</div>
      <button id="rollDice2" class="diceButton" disabled>Roll Dice</button>
      <div id="dice2" class="diceDisplay">üé≤</div>
      <div id="moves2" class="movesLeft">Moves left: 0</div>
    </div>
  </div>

  <div id="questionBox">
    <h3 id="questionText"></h3>
    <div id="answersContainer"></div>
    <div id="feedback"></div>
  </div>

  <script>
    let gameMode = 0;
    let lessonType = "variables";

    function startGame(mode) {
      gameMode = mode;
      lessonType = document.getElementById('lessonSelect').value;
      document.getElementById('modeSelection').classList.add('hidden');

      if (mode === 1) {
        document.getElementById('player2Dice').style.display = 'none';
        document.getElementById('turnIndicator').textContent = "Single Player Mode";
      }

      createPeppaMaze("gameContainer");
    }

    function createPeppaMaze(containerId) {
      const container = document.getElementById(containerId);
      container.innerHTML = `<canvas id="mazeCanvas"></canvas>`;

      const canvas = container.querySelector("#mazeCanvas");
      const ctx = canvas.getContext("2d");
      const questionBox = document.getElementById("questionBox");
      const questionText = document.getElementById("questionText");
      const answersContainer = document.getElementById("answersContainer");
      const feedback = document.getElementById("feedback");
      const turnIndicator = document.getElementById("turnIndicator");

      const rollDice1Btn = document.getElementById("rollDice1");
      const rollDice2Btn = document.getElementById("rollDice2");
      const dice1Display = document.getElementById("dice1");
      const dice2Display = document.getElementById("dice2");
      const moves1Display = document.getElementById("moves1");
      const moves2Display = document.getElementById("moves2");
      const player1DiceDiv = document.getElementById("player1Dice");
      const player2DiceDiv = document.getElementById("player2Dice");

      canvas.width = 600;
      canvas.height = 600;

      const cellSize = 60;
      const rows = 10;
      const cols = 10;
      const maze = [
        [0, 0, 1, 0, 0, 0, 0, 1, 0, 0],
        [1, 0, 1, 0, 1, 1, 0, 1, 0, 1],
        [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
        [0, 1, 1, 1, 0, 1, 1, 1, 1, 0],
        [0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
        [0, 1, 0, 1, 1, 1, 0, 1, 0, 1],
        [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [1, 1, 1, 1, 1, 1, 1, 1, 0, 0]
      ];

      const numbers = {
        "1": { x: 1, y: 0 }, "2": { x: 4, y: 0 }, "3": { x: 8, y: 0 },
        "4": { x: 0, y: 4 }, "5": { x: 5, y: 4 }, "6": { x: 9, y: 4 },
        "7": { x: 0, y: 8 }, "8": { x: 5, y: 8 }, "9": { x: 9, y: 9 }
      };

      const variableFacts = [
        { question: "Variables are named storage locations that hold data your program needs.", answers: ["True", "False"], correct: 0, explanation: "True! Think of variables as labeled boxes where you store and retrieve information." },
        { question: "In Python, you need a special keyword to create a variable.", answers: ["True", "False"], correct: 1, explanation: "False! Python creates variables with simple assignment: peppa_x = 0" },
        { question: "In JavaScript, you should use 'let' for values that change and 'const' for constants.", answers: ["True", "False"], correct: 0, explanation: "True! 'let' allows reassignment while 'const' keeps values constant." },
        { question: "Python uses snake_case naming (like peppa_position).", answers: ["True", "False"], correct: 0, explanation: "True! Python convention uses lowercase with underscores between words." },
        { question: "JavaScript uses snake_case naming (like peppa_position).", answers: ["True", "False"], correct: 1, explanation: "False! JavaScript uses camelCase (like peppaPosition) - capitalize first letter of each new word." },
        { question: "The assignment operator '=' means 'store this value'.", answers: ["True", "False"], correct: 0, explanation: "True! In peppa_x = 0, the '=' stores the value 0 in the variable peppa_x." },
        { question: "You can update a variable's value after creating it.", answers: ["True", "False"], correct: 0, explanation: "True! Variables are called 'variable' because their values can vary: x = x + 1" },
        { question: "Good variable names should be short single letters like 'x' or 'p'.", answers: ["True", "False"], correct: 1, explanation: "False! Use descriptive names like 'movesLeft' instead of just 'm' to make code readable." },
        { question: "Booleans can store true/false values.", answers: ["True", "False"], correct: 0, explanation: "True! Booleans flip between true and false, like: animating = true" },
        { question: "You can change strings stored in variables.", answers: ["True", "False"], correct: 0, explanation: "True! You can reassign: currentMessage = 'Peppa's turn!' then later currentMessage = 'George's turn!'" },
        { question: "Variables remember information while the program runs.", answers: ["True", "False"], correct: 0, explanation: "True! Without variables, games would forget positions, scores, and other important data." },
        { question: "In the Peppa Maze, variables track position, moves, and game state.", answers: ["True", "False"], correct: 0, explanation: "True! The game uses peppaX, peppaY, movesLeft, currentPlayer, and more." },
        { question: "When updating x = x + 1, the computer first reads the old value, then calculates and stores the new value.", answers: ["True", "False"], correct: 0, explanation: "True! Step 1: Read current value. Step 2: Calculate new value. Step 3: Store result back." },
        { question: "You must use quotes around text when storing it in a variable.", answers: ["True", "False"], correct: 0, explanation: "True! Without quotes in name = Peppa, it thinks Peppa is a variable. Use name = 'Peppa'." },
        { question: "Multiple variables can work together to track complex game state.", answers: ["True", "False"], correct: 0, explanation: "True! Games use many variables together: position (x,y), moves, player turn, animating state, etc." }
      ];

      const algorithmFacts = [
        { question: "An algorithm is a clear, step-by-step process for solving a problem.", answers: ["True", "False"], correct: 0, explanation: "True! Like a recipe, each instruction must be followed in order to reach the correct result." },
        { question: "Different algorithms can solve the same problem in different ways.", answers: ["True", "False"], correct: 0, explanation: "True! You can sum numbers manually with a loop, or use a built-in function - both work!" },
        { question: "Boolean expressions evaluate to either true or false.", answers: ["True", "False"], correct: 0, explanation: "True! Conditions like x > y or isEven(num) return boolean values for decision-making." },
        { question: "Conditional statements tell the computer to do something only if a condition is true.", answers: ["True", "False"], correct: 0, explanation: "True! if/else statements use boolean logic to make decisions in algorithms." },
        { question: "In the Peppa Maze, the movement algorithm checks for walls before moving.", answers: ["True", "False"], correct: 0, explanation: "True! The canPeppaMove() function validates moves against boundaries and walls." },
        { question: "Algorithms should only be written in code, never in plain English.", answers: ["True", "False"], correct: 1, explanation: "False! Many algorithms are first described in natural language or pseudocode before coding." },
        { question: "The modulo operator (%) can check if a number is even or odd.", answers: ["True", "False"], correct: 0, explanation: "True! num % 2 === 0 checks if a number is even (remainder of 0 when divided by 2)." },
        { question: "A loop is an algorithm that repeats steps multiple times.", answers: ["True", "False"], correct: 0, explanation: "True! Loops like 'for' and 'while' execute the same instructions repeatedly." },
        { question: "Testing algorithms means trying many different inputs to ensure correctness.", answers: ["True", "False"], correct: 0, explanation: "True! Good testing covers edge cases, normal cases, and invalid inputs." },
        { question: "The Peppa Maze uses an algorithm to animate smooth movement between cells.", answers: ["True", "False"], correct: 0, explanation: "True! The animate() function gradually moves Peppa using progress from 0 to 1." },
        { question: "Algorithms can combine multiple operations like checking, updating, and drawing.", answers: ["True", "False"], correct: 0, explanation: "True! The movePeppa algorithm validates, animates, updates position, decrements moves, and checks for questions." },
        { question: "Built-in functions like max() or sum() use optimized algorithms.", answers: ["True", "False"], correct: 0, explanation: "True! Languages provide pre-made, efficient algorithms for common tasks." },
        { question: "An algorithm always produces the same result for the same input.", answers: ["True", "False"], correct: 0, explanation: "True! Deterministic algorithms are consistent and predictable." },
        { question: "Breaking problems into smaller steps makes algorithms easier to understand.", answers: ["True", "False"], correct: 0, explanation: "True! Functions like drawMaze(), drawPlayer(), and checkForQuestion() each handle one clear task." },
        { question: "Debugging means finding and fixing issues in an algorithm without starting over.", answers: ["True", "False"], correct: 0, explanation: "True! Debug by testing, identifying problems, and making targeted fixes." }
      ];

      const efficiencyFacts = [
        { question: "Algorithmic efficiency measures how fast an algorithm runs and how much memory it uses.", answers: ["True", "False"], correct: 0, explanation: "True! Efficiency is about speed (time) and space (memory) ‚Äî the two main resources algorithms use." },
        { question: "A more efficient algorithm finishes slower and uses more memory.", answers: ["True", "False"], correct: 1, explanation: "False! A more efficient algorithm finishes faster and uses less memory." },
        { question: "Time complexity describes how the number of steps grows as the input size increases.", answers: ["True", "False"], correct: 0, explanation: "True! Time complexity measures how runtime changes when the problem gets bigger." },
        { question: "Big-O notation gives the exact number of steps an algorithm takes.", answers: ["True", "False"], correct: 1, explanation: "False! Big-O shows how fast work grows, not the exact count ‚Äî it‚Äôs about the trend." },
        { question: "O(1) means the algorithm‚Äôs work stays constant no matter how big the input is.", answers: ["True", "False"], correct: 0, explanation: "True! Constant time means no extra work even if input grows ‚Äî like checking if a number is even." },
        { question: "O(n) means the number of steps doubles every time the input doubles.", answers: ["True", "False"], correct: 1, explanation: "False! That‚Äôs O(n¬≤). In O(n), steps grow in direct proportion ‚Äî double input, double work." },
        { question: "O(n¬≤) algorithms grow much faster than O(n) ones as input size increases.", answers: ["True", "False"], correct: 0, explanation: "True! Quadratic growth means doubling input can make work four times larger." },
        { question: "O(2‚Åø) is one of the most efficient algorithm types.", answers: ["True", "False"], correct: 1, explanation: "False! O(2‚Åø) grows explosively ‚Äî doubling input doubles the work, making it very inefficient." },
        { question: "In Python, a while loop that runs ‚Äòn‚Äô times has O(n) time complexity.", answers: ["True", "False"], correct: 0, explanation: "True! Each iteration adds one step per item, so it‚Äôs linear (O(n))." },
        { question: "Nested loops, like a loop inside another loop, usually create quadratic time complexity.", answers: ["True", "False"], correct: 0, explanation: "True! One loop runs for each run of the other, multiplying work: O(n * n) = O(n¬≤)." },
        { question: "Processing power and time are unlimited, so algorithmic efficiency doesn‚Äôt really matter.", answers: ["True", "False"], correct: 1, explanation: "False! Computers have limits ‚Äî efficient code saves time, energy, and memory." },
        { question: "Memory usage is often related to an algorithm‚Äôs time complexity.", answers: ["True", "False"], correct: 0, explanation: "True! Algorithms that handle lots of data often use more time and memory together." },
        { question: "O(1) and O(n¬≤) algorithms usually perform about the same on large inputs.", answers: ["True", "False"], correct: 1, explanation: "False! Constant time (O(1)) stays fast; quadratic time (O(n¬≤)) quickly slows down for big inputs." },
        { question: "Big-O notation helps programmers compare which algorithms will run faster as data grows.", answers: ["True", "False"], correct: 0, explanation: "True! Big-O is used to compare performance and scalability between algorithms." },
        { question: "Efficient algorithms save time, use less memory, and handle large problems better.", answers: ["True", "False"], correct: 0, explanation: "True! That‚Äôs the goal ‚Äî make code that runs quickly and scales well." }
];


  // Choose question set: algorithms, algorithmic efficiency, or variables
        const allQuestions = (lessonType === "algorithms" ? algorithmFacts : (lessonType === "algorithmic efficiency" ? efficiencyFacts : variableFacts)).slice();
        let availableQuestions = shuffleArray(allQuestions);
        let usedQuestions = new Set();

      function shuffleArray(array) {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      let currentPlayer = 1;
      let waitingForAnswer = false;
      let questionedPlayer = null;

      const player1 = {
        x: 0, y: 0, moves: 0, color: "#ff69b4", name: "Peppa"
      };
      const player2 = {
        x: 1, y: 0, moves: 0, color: "#4169e1", name: "George"
      };

      let animating = false;

      function drawMaze() {
        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            ctx.fillStyle = maze[y][x] === 1 ? "#444" : "#fff";
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            ctx.strokeStyle = "#000";
            ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
          }
        }
        ctx.fillStyle = "blue";
        ctx.font = "20px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (const num in numbers) {
          const pos = numbers[num];
          ctx.fillText(num, pos.x * cellSize + cellSize / 2, pos.y * cellSize + cellSize / 2);
        }
      }

      function drawPlayer(player) {
        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2, cellSize / 3, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(player.x * cellSize + cellSize / 2 - 5, player.y * cellSize + cellSize / 2 - 5, 2, 0, 2 * Math.PI);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(player.x * cellSize + cellSize / 2 + 5, player.y * cellSize + cellSize / 2 - 5, 2, 0, 2 * Math.PI);
        ctx.fill();
      }

      function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawMaze();
        drawPlayer(player1);
        if (gameMode === 2) drawPlayer(player2);
        requestAnimationFrame(update);
      }

      function switchTurn() {
        currentPlayer = (currentPlayer === 1 ? 2 : 1);
        updateTurnDisplay();
      }

      function updateTurnDisplay() {
        if (gameMode === 1) {
          turnIndicator.textContent = "Single Player Mode";
          turnIndicator.style.color = "#ff69b4";
          return;
        }
        if (currentPlayer === 1) {
          turnIndicator.textContent = "üê∑ Peppa's Turn!";
          turnIndicator.style.color = "#ff69b4";
          player1DiceDiv.classList.add("current-turn");
          player2DiceDiv.classList.remove("current-turn");
          rollDice1Btn.disabled = false;
          rollDice2Btn.disabled = true;
        } else {
          turnIndicator.textContent = "üêñ George's Turn!";
          turnIndicator.style.color = "#4169e1";
          player2DiceDiv.classList.add("current-turn");
          player1DiceDiv.classList.remove("current-turn");
          rollDice1Btn.disabled = true;
          rollDice2Btn.disabled = false;
        }
      }

      function rollDice(player, diceDisplay, movesDisplay, rollButton) {
        const roll = Math.floor(Math.random() * 6) + 1;
        player.moves += roll;
        diceDisplay.textContent = `üé≤ ${roll}`;
        movesDisplay.textContent = `Moves left: ${player.moves}`;
        if (gameMode === 2) rollButton.disabled = true;
      }

      function updateMovesDisplay(player, movesDisplay) {
        movesDisplay.textContent = `Moves left: ${player.moves}`;
        if (gameMode === 1 && player.moves === 0) {
          rollDice1Btn.disabled = false;
        }
      }

      function isValidMove(x, y, movingPlayer) {
        if (x < 0 || x >= cols || y < 0 || y >= rows || maze[y][x] === 1) return false;
        return true;
      }

      function movePlayer(player, dx, dy, movesDisplay) {
        if (animating || player.moves <= 0 || waitingForAnswer) return;
        if ((currentPlayer === 1 && player !== player1) || (currentPlayer === 2 && player !== player2)) return;
        if (gameMode === 1 && player !== player1) return;

        const newX = player.x + dx;
        const newY = player.y + dy;
        if (!isValidMove(newX, newY, player)) return;

        animating = true;
        const startX = player.x;
        const startY = player.y;
        let progress = 0;

        function animate() {
          progress += 0.1;
          if (progress >= 1) {
            player.x = newX;
            player.y = newY;
            player.moves--;
            updateMovesDisplay(player, movesDisplay);
            animating = false;
            checkForQuestion(player);
            if (player.moves === 0 && !waitingForAnswer && gameMode === 2) switchTurn();
            return;
          }
          player.x = startX + (newX - startX) * progress;
          player.y = startY + (newY - startY) * progress;
          requestAnimationFrame(animate);
        }

        animate();
      }

      function checkForQuestion(player) {
        const playerX = Math.round(player.x);
        const playerY = Math.round(player.y);
        for (const num in numbers) {
          const pos = numbers[num];
          if (playerX === pos.x && playerY === pos.y) {
            showQuestion(num, player);
            break;
          }
        }
      }

      function showQuestion(num, player) {
        if (availableQuestions.length === 0) {
          availableQuestions = shuffleArray(allQuestions);
          usedQuestions.clear();
        }
        const q = availableQuestions.shift();
        if (q) usedQuestions.add(q);
        if (!q) return;

        waitingForAnswer = true;
        questionedPlayer = player;

        questionText.textContent = player.name + ", " + q.question;
        answersContainer.innerHTML = '';
        feedback.style.display = 'none';

        q.answers.forEach((answer, index) => {
          const btn = document.createElement('button');
          btn.className = 'answer-btn';
          btn.textContent = answer;
          btn.onclick = () => checkAnswer(index, q.correct, q.explanation, player);
          answersContainer.appendChild(btn);
        });

        questionBox.style.display = 'block';
      }

      function checkAnswer(selected, correct, explanation, player) {
        const buttons = answersContainer.querySelectorAll('.answer-btn');
        buttons.forEach(btn => btn.disabled = true);

        if (selected === correct) {
          feedback.className = 'correct';
          feedback.textContent = `‚úì Correct! ${explanation}`;
        } else {
          feedback.className = 'incorrect';
          feedback.textContent = `‚úó Incorrect. ${explanation}`;
          setTimeout(() => movePlayerBack(player), 2000);
        }

        feedback.style.display = 'block';

        setTimeout(() => {
          questionBox.style.display = 'none';
          waitingForAnswer = false;
          if (player.moves === 0 && gameMode === 2) switchTurn();
        }, 3000);
      }

      function movePlayerBack(player) {
        const directions = [
          { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
        ];
        for (const dir of directions) {
          const newX = player.x + dir.dx;
          const newY = player.y + dir.dy;
          if (isValidMove(newX, newY, player)) {
            animating = true;
            const startX = player.x;
            const startY = player.y;
            let progress = 0;
            function animateBack() {
              progress += 0.15;
              if (progress >= 1) {
                player.x = newX;
                player.y = newY;
                animating = false;
                return;
              }
              player.x = startX + (newX - startX) * progress;
              player.y = startY + (newY - startY) * progress;
              requestAnimationFrame(animateBack);
            }
            animateBack();
            break;
          }
        }
      }

      rollDice1Btn.addEventListener("click", () => {
        rollDice(player1, dice1Display, moves1Display, rollDice1Btn);
      });
      rollDice2Btn.addEventListener("click", () => {
        rollDice(player2, dice2Display, moves2Display, rollDice2Btn);
      });

      document.addEventListener("keydown", function (e) {
        if (gameMode === 1 || currentPlayer === 1) {
          if (e.key === "w" || e.key === "W") movePlayer(player1, 0, -1, moves1Display);
          else if (e.key === "a" || e.key === "A") movePlayer(player1, -1, 0, moves1Display);
          else if (e.key === "s" || e.key === "S") movePlayer(player1, 0, 1, moves1Display);
          else if (e.key === "d" || e.key === "D") movePlayer(player1, 1, 0, moves1Display);
        }
        if (gameMode === 2 && currentPlayer === 2) {
          if (e.key === "ArrowUp") { e.preventDefault(); movePlayer(player2, 0, -1, moves2Display); }
          else if (e.key === "ArrowLeft") { e.preventDefault(); movePlayer(player2, -1, 0, moves2Display); }
          else if (e.key === "ArrowDown") { e.preventDefault(); movePlayer(player2, 0, 1, moves2Display); }
          else if (e.key === "ArrowRight") { e.preventDefault(); movePlayer(player2, 1, 0, moves2Display); }
        }
      });

      updateTurnDisplay();
      update();
    }
  </script>
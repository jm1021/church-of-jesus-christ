<!-- Tutorial Overlay -->
<div id="tutorial-overlay">
    <div id="tutorial-content">
        <h1>How To Play</h1>
        
        <h2>üéØ Goal</h2>
        <p>Get the KEY to touch the DOOR to complete the level!</p>
        
        <h2>üñ±Ô∏è Selecting Tiles</h2>
        <ul>
            <li><strong>Click</strong> any tile in the green area to select it</li>
            <li>Selected tiles get a yellow outline</li>
            <li>You can only select tiles inside the green area</li>
        </ul>
        
        <h2>üé® Adding Tiles</h2>
        <p><strong>Step 1:</strong> Click an empty green space<br>
        <strong>Step 2:</strong> Press a number key to place a tile:</p>
        <ul>
            <li><strong>1</strong> - Block (Basic movable block)</li>
            <li><strong>2</strong> - Pusher (Moves automatically, press O to start)</li>
            <li><strong>3</strong> - Heavy Block (Can be pushed)</li>
            <li><strong>4</strong> - Rotater (Can rotate)</li>
            <li><strong>5</strong> - Slider (Slides across the grid)</li>
        </ul>
        
        <h2>‚å®Ô∏è Keyboard Controls</h2>
        <ul>
            <li><strong>‚Üê‚Üë‚Üì‚Üí</strong> - Move selected tiles</li>
            <li><strong>Q</strong> - Rotate tile left</li>
            <li><strong>R</strong> - Rotate tile right</li>
            <li><strong>O</strong> - Start pushers moving</li>
            <li><strong>ESC</strong> - Stop pushers</li>
        </ul>
        
        <h2>üéÆ Button Controls</h2>
        <ul>
            <li><strong>‚Üê Prev Level / Next Level ‚Üí</strong> - Change levels</li>
            <li><strong>üîÑ Reset Level</strong> - Restart current level</li>
            <li><strong>Rotate CW / CCW</strong> - Rotate selected tile</li>
            <li><strong>Start Pushers</strong> - Make pusher tiles move</li>
            <li><strong>Stop Pushers</strong> - Stop all pusher movement</li>
        </ul>
        
        <button id="close-tutorial">Start Playing!</button>
    </div>
</div>

<div id="controls">
    <div id="level-info">Level 1 of 3</div>
    <button id="prev-level">‚Üê Prev Level</button>
    <button id="next-level">Next Level ‚Üí</button>
    <button id="reset-level">üîÑ Reset Level</button>
    <button id="rotate-cw">Rotate CW</button>
    <button id="rotate-ccw">Rotate CCW</button>
    <button id="start-pushers">Start Pushers (O)</button>
    <button id="stop-pushers">Stop Pushers (Esc)</button>
</div>

<div id="grid-container"></div>

<script type="module" src="/assets/js/block-unlock/tile.js"></script>
<script type="module" src="/assets/js/block-unlock/grid-system.js"></script>
<script type="module" src="/assets/js/block-unlock/level-system.js"></script>

<script>
// Close tutorial overlay - must run before module script
let tutorialClosed = false;

document.addEventListener('DOMContentLoaded', () => {
    const closeBtn = document.getElementById('close-tutorial');
    const overlay = document.getElementById('tutorial-overlay');
    
    if (closeBtn && overlay) {
        closeBtn.addEventListener('click', () => {
            console.log('Close button clicked!');
            overlay.classList.add('hidden');
            tutorialClosed = true;
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        });
    }
});

// Allow closing tutorial with ESC
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && !tutorialClosed) {
        const overlay = document.getElementById('tutorial-overlay');
        if (overlay && !overlay.classList.contains('hidden')) {
            console.log('ESC pressed - closing tutorial');
            overlay.classList.add('hidden');
            tutorialClosed = true;
            e.preventDefault();
            return;
        }
    }
});
</script>

<script type="module">
import { Grid } from "/assets/js/block-unlock/grid-system.js";
import { Tile } from "/assets/js/block-unlock/tile.js";
import { LevelLoader } from "/assets/js/block-unlock/level-system.js";

let container = document.getElementById("grid-container");
const BASE_CELL_SIZE = 60;

// Track mouse position for tile placement
let lastMouseX = 0;
let lastMouseY = 0;
let lastClickedCell = null;

document.addEventListener('mousemove', (e) => {
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
});

// Create grid - will be resized by level loader
const g = new Grid(10, 10, 0);
g.startGame = true;
g.SetToGrid();

// Create level loader
let cells = [];
const levelLoader = new LevelLoader(g, container, cells);

// Set up level completion callback
g.onLevelComplete = () => {
    console.log("=== üéâ LEVEL COMPLETION TRIGGERED üéâ ===");
    
    // Stop all pushers immediately
    g.stopAllPushers();
    console.log("All pushers stopped");
    
    // Wait for visual feedback, then load next level
    setTimeout(async () => {
        console.log("Loading next level...");
        const hasNext = await levelLoader.nextLevel();
        
        if (!hasNext) {
            console.log("No more levels - game complete!");
            alert("üéâ Congratulations! You completed all levels!");
        } else {
            console.log("Next level loaded, updating display...");
            updateLevelDisplay();
            recreateDisplay();
            console.log("Display updated successfully");
        }
        console.log("=== LEVEL TRANSITION COMPLETE ===");
    }, 800);
};

// Helper: direction -> degrees
function directionToAngle(dir){
    switch(dir){
        case 'east': return 90;
        case 'south': return 180;
        case 'west': return 270;
        default: return 0;
    }
}

function recreateDisplay() {
    // Get fresh reference to container
    container = document.getElementById("grid-container");
    
    // Clear container
    container.innerHTML = '';
    cells.length = 0;

    // Update container styling
    container.style.setProperty("--grid-cols", g.Xsize);
    container.style.setProperty("--grid-rows", g.Ysize);
    container.style.setProperty("--cell-size", `${BASE_CELL_SIZE}px`);
    container.style.gridTemplateColumns = `repeat(${g.Xsize}, 1fr)`;
    container.style.gridTemplateRows = `repeat(${g.Ysize}, 1fr)`;

    // Recreate cells
    for(let y=0; y<g.Ysize; y++){
        for(let x=0; x<g.Xsize; x++){
            const cell = document.createElement("div");
            cell.dataset.x = x;
            cell.dataset.y = y;
            cell.classList.add("grid-cell");

            const bg = document.createElement("div");
            bg.classList.add("cell-bg");
            
            // Add border styling if this cell has borders
            const border = g.getBorder(x, y);
            if (border) {
                bg.classList.add("placeable");
                if (border.directions.includes('n')) bg.classList.add("border-n");
                if (border.directions.includes('s')) bg.classList.add("border-s");
                if (border.directions.includes('e')) bg.classList.add("border-e");
                if (border.directions.includes('w')) bg.classList.add("border-w");
            }
            
            cell.appendChild(bg);

            const spriteDiv = document.createElement("div");
            spriteDiv.classList.add("cell-tile");

            const key = `${x},${y}`;
            const tile = g.tileMap[key];

            if(tile && tile.sprite){
                spriteDiv.style.backgroundImage = `url('${tile.sprite}')`;
                spriteDiv.style.setProperty('--rotation', `${directionToAngle(tile.direction)}deg`);
            } else {
                spriteDiv.style.backgroundImage = `url('data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=')`;
                spriteDiv.style.setProperty('--rotation', `0deg`);
            }

            cell.appendChild(spriteDiv);
            container.appendChild(cell);
            cells.push({cell, spriteDiv, bg});
        }
    }

    // Add event listeners directly - no separate function
    container.addEventListener("click", handleCellClick);
    
    // Update selection visual after recreation
    updateSelectionVisual();
}

function handleCellClick(e) {
    const cell = e.target.closest('.grid-cell');
    if(!cell) return;
    
    const x = parseInt(cell.dataset.x);
    const y = parseInt(cell.dataset.y);
    
    console.log(`Clicked cell (${x}, ${y}), placeable: ${g.isPlaceable(x, y)}`);
    
    // Store clicked cell for tile placement
    lastClickedCell = {x, y};
    
    // Try to select tile (works for existing tiles in placeable areas)
    g.selectTile([x,y]);
    updateSelectionVisual();
}

function updateLevelDisplay() {
    const info = levelLoader.getCurrentLevelInfo();
    const levelInfoDiv = document.getElementById("level-info");
    if (levelInfoDiv) {
        levelInfoDiv.textContent = `${info.name} (${info.index}/${info.total})`;
    }
}

// Load initial level
levelLoader.loadCurrentLevel().then(() => {
    updateLevelDisplay();
    recreateDisplay();
});

// Update function
g.subscribe((x,y,value)=>{
    const index = y*g.Xsize + x;
    if (!cells[index]) return;
    
    const {spriteDiv} = cells[index];
    const key = `${x},${y}`;
    const tile = g.tileMap[key];

    if(tile && tile.sprite){
        spriteDiv.style.backgroundImage = `url('${tile.sprite}')`;
        spriteDiv.style.setProperty('--rotation', `${directionToAngle(tile.direction)}deg`);
    } else {
        spriteDiv.style.backgroundImage = `url('data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=')`;
        spriteDiv.style.setProperty('--rotation', `0deg`);
    }
    updateSelectionVisual();
});

// Selection visual
function updateSelectionVisual(){
    if (!cells.length) return;
    
    // Clear all selections
    cells.forEach(c=> {
        if (c && c.bg) c.bg.classList.remove('selected');
    });
    
    // Add selection to selected tile
    if(g.selectedTile){
        const [sx,sy] = g.selectedTile.CordLocation;
        const index = sy*g.Xsize + sx;
        if(cells[index] && cells[index].bg){
            cells[index].bg.classList.add('selected');
            console.log(`Selected tile at (${sx}, ${sy})`);
        }
    }
}

// Key handling
window.addEventListener("keydown", e=>{
    if(e.key==='o'||e.key==='O'){ 
        console.log("'O' key pressed - starting pushers");
        console.log("Grid startGame flag:", g.startGame);
        g.startPushers(); 
        e.preventDefault(); 
        return; 
    }
    if(e.key==='Escape' && tutorialClosed){ 
        g.stopAllPushers(); 
        e.preventDefault(); 
        return; 
    }

    // Number key tile placement (1-5)
    const num = parseInt(e.key);
    if(num >= 1 && num <= 5) {
        let targetX, targetY;
        
        // Use last clicked cell if available and placeable
        if (lastClickedCell && g.isPlaceable(lastClickedCell.x, lastClickedCell.y)) {
            targetX = lastClickedCell.x;
            targetY = lastClickedCell.y;
        } 
        // Fallback to selected tile position
        else if (g.selectedTile) {
            [targetX, targetY] = g.selectedTile.CordLocation;
        }
        // Last resort: try mouse position
        else {
            const hoveredCell = document.elementFromPoint(lastMouseX || 0, lastMouseY || 0);
            if (hoveredCell) {
                const cell = hoveredCell.closest('.grid-cell');
                if (cell) {
                    targetX = parseInt(cell.dataset.x);
                    targetY = parseInt(cell.dataset.y);
                }
            }
        }
        
        if (targetX !== undefined && targetY !== undefined) {
            console.log(`Trying to place tile ${num} at (${targetX}, ${targetY})`);
            g.placeTile(targetX, targetY, num);
            e.preventDefault();
            return;
        }
    }

    if(!g.selectedTile) return;
    const map={ArrowUp:"up",ArrowDown:"down",ArrowLeft:"left",ArrowRight:"right"};
    if(map[e.key]){ 
        console.log(`Moving selected tile ${map[e.key]}`);
        g.moveSelected(map[e.key]); 
        e.preventDefault(); 
        updateSelectionVisual(); 
        return; 
    }

    if(e.key==='r'||e.key==='R'){ g.rotateSelected(true); e.preventDefault(); updateSelectionVisual(); return; }
    if(e.key==='q'||e.key==='Q'){ g.rotateSelected(false); e.preventDefault(); updateSelectionVisual(); return; }
});

// Button handlers
document.getElementById("prev-level")?.addEventListener("click", async ()=>{ 
    console.log("Previous level clicked");
    await levelLoader.prevLevel(); 
    updateLevelDisplay(); 
    recreateDisplay(); 
});

document.getElementById("next-level")?.addEventListener("click", async ()=>{ 
    console.log("Next level clicked");
    await levelLoader.nextLevel(); 
    updateLevelDisplay(); 
    recreateDisplay(); 
});

document.getElementById("rotate-cw")?.addEventListener("click", ()=>{ 
    g.rotateSelected(true); 
    updateSelectionVisual(); 
});

document.getElementById("rotate-ccw")?.addEventListener("click", ()=>{ 
    g.rotateSelected(false); 
    updateSelectionVisual(); 
});

document.getElementById("start-pushers")?.addEventListener("click", ()=>{ 
    console.log("Start Pushers button clicked!");
    console.log("Grid startGame flag:", g.startGame);
    g.startPushers(); 
});

document.getElementById("stop-pushers")?.addEventListener("click", ()=>{ 
    g.stopAllPushers(); 
});

document.getElementById("reset-level")?.addEventListener("click", async ()=>{ 
    console.log("Reset level clicked");
    await levelLoader.resetCurrentLevel(); 
    updateLevelDisplay(); 
    recreateDisplay(); 
});

</script>

<style>
/* Tutorial Overlay Styles */
#tutorial-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
    opacity: 1;
    transition: opacity 0.3s ease;
}

#tutorial-overlay.hidden {
    opacity: 0;
    pointer-events: none;
}

#tutorial-content {
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border: 3px solid #00ff88;
    border-radius: 15px;
    padding: 30px;
    max-width: 600px;
    max-height: 85vh;
    overflow-y: auto;
    box-shadow: 0 10px 50px rgba(0, 255, 136, 0.3);
    color: #fff;
}

#tutorial-content h1 {
    color: #00ff88;
    text-align: center;
    margin-top: 0;
    font-size: 2em;
    text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
}

#tutorial-content h2 {
    color: #ffdd57;
    margin-top: 25px;
    margin-bottom: 10px;
    font-size: 1.4em;
}

#tutorial-content p, #tutorial-content ul {
    line-height: 1.6;
    color: #e0e0e0;
}

#tutorial-content ul {
    padding-left: 20px;
}

#tutorial-content li {
    margin-bottom: 8px;
}

#tutorial-content strong {
    color: #00ff88;
}

#close-tutorial {
    display: block;
    width: 200px;
    margin: 30px auto 0;
    padding: 15px 30px;
    background: linear-gradient(135deg, #00ff88 0%, #00cc70 100%);
    color: #1a1a2e;
    border: none;
    border-radius: 25px;
    font-size: 1.1em;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 5px 15px rgba(0, 255, 136, 0.4);
}

#close-tutorial:hover {
    transform: translateY(-2px);
    box-shadow: 0 7px 20px rgba(0, 255, 136, 0.6);
}

/* Scrollbar styling for tutorial */
#tutorial-content::-webkit-scrollbar {
    width: 10px;
}

#tutorial-content::-webkit-scrollbar-track {
    background: #16213e;
    border-radius: 10px;
}

#tutorial-content::-webkit-scrollbar-thumb {
    background: #00ff88;
    border-radius: 10px;
}

/* Game Styles */
#controls{ text-align:center; margin-bottom:10px; }
#controls button{ margin:0 5px; padding:6px 10px; cursor:pointer; }

#level-info {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 10px;
    color: #fff;
}

#grid-container{
    display:grid;
    gap:1px;
    width:90vw;
    max-width:900px;
    margin:0 auto;
    background:#222;
    border:2px solid #555;
}

.grid-cell{
    position:relative;
    width: var(--cell-size);
    height: var(--cell-size);
}

.cell-bg{
    position:absolute;
    top:0; left:0; right:0; bottom:0;
    background:#333;
    border:1px solid #888;
    transition:box-shadow 0.12s, border 0.12s;
}

.cell-bg.selected{
    border:3px solid #ff0 !important;
    box-shadow:0 0 10px rgba(255,255,0,0.5) !important;
}

/* Placeable area styling */
.cell-bg.placeable{
    background:#2a4a2a; /* Slightly green tint for placeable areas */
}

/* Border directions - thicker and more visible */
.cell-bg.border-n{
    border-top: 4px solid #00ff88;
}

.cell-bg.border-s{
    border-bottom: 4px solid #00ff88;
}

.cell-bg.border-e{
    border-right: 4px solid #00ff88;
}

.cell-bg.border-w{
    border-left: 4px solid #00ff88;
}

.cell-tile{
    position:absolute;
    top:0; left:0; right:0; bottom:0;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
    transition:transform 0.18s;
    transform: rotate(var(--rotation,0deg));
}

.grid-cell:hover .cell-tile{
    transform: scale(1.05) rotate(var(--rotation,0deg));
    cursor:pointer;
}

/* Hover effect for placeable areas */
.grid-cell:hover .cell-bg.placeable{
    background:#3a5a3a;
}
</style>